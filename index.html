<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <title>Car Rider 3D</title>
    <style>
        /* General page styling */
        body { 
            margin: 0; 
            overflow: hidden; 
            background: black; 
        }
        canvas { 
            display: block; 
        }
        
        /* Styling for the UI elements */
        #speedometer, #score, #progress, #fuelMeter {
            position: fixed;
            top: 10px;
            left: 10px;
            color: white;
            font-family: monospace;
            background: rgba(0,0,0,0.5);
            padding: 10px;
            border-radius: 5px;
            user-select: none;
            font-size: 16px;
        }
        #score {
            top: 40px;
        }
        #fuelMeter {
            top: 70px;
            background: linear-gradient(90deg, #ff4136 0%, #ff851b 50%, #2ecc40 100%);
            width: 150px;
            height: 10px;
            border-radius: 5px;
            overflow: hidden;
            border: 1px solid white;
        }
        #fuelBar {
            background-color: #000;
            width: 100%;
            height: 100%;
            transition: width 0.1s linear;
        }
        #debugPanel {
            position: fixed;
            top: 100px;
            left: 10px;
            color: yellow;
            font-family: monospace;
            background: rgba(0,0,0,0.7);
            padding: 10px;
            border-radius: 5px;
            user-select: none;
            font-size: 16px;
            display: none; /* The debug panel is now hidden by default */
        }
        #progress {
            top: 150px;
        }
    </style>
</head>
<body>
    <div id="speedometer">Speed: 0</div>
    <div id="score">Score: 0</div>
    <div id="fuelMeter"><div id="fuelBar"></div></div>
    <div id="debugPanel">Initializing...</div>
    <div id="progress"></div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>

    <script>
        const GLTFLoader = THREE.GLTFLoader;

        // --- DEBUG PANEL ---
        const debugPanel = document.getElementById('debugPanel');
        let logs = [];
        function log(message) {
            logs.push(message);
            if (logs.length > 10) { 
                logs.shift();
            }
            debugPanel.innerHTML = logs.join('<br>');
        }
        
        log("1. Starting up.");
        
        try {
            log("2. Attempting to create Three.js Scene.");
            const scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87ceeb);
            log("3. Scene created successfully.");

            log("4. Attempting to set up camera and renderer.");
            const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 6, 12);
            
            const renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.body.appendChild(renderer.domElement);
            log("5. Camera and renderer created successfully.");

            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });

            // --- Lighting ---
            const ambientLight = new THREE.AmbientLight(0xffffff, 1.2);
            scene.add(ambientLight);
            log("6. Ambient light added.");

            const directionalLight = new THREE.DirectionalLight(0xffffff, 1.5);
            directionalLight.position.set(10, 50, 10);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            scene.add(directionalLight);
            log("7. Directional light added.");

            const fillLight1 = new THREE.DirectionalLight(0xffffff, 0.8);
            fillLight1.position.set(-10, 20, -10);
            scene.add(fillLight1);
            log("8. Fill light 1 added.");

            const fillLight2 = new THREE.DirectionalLight(0xffffff, 0.5);
            fillLight2.position.set(0, 10, -20);
            scene.add(fillLight2);
            log("9. Fill light 2 added.");

            // --- Ground ---
            const groundGeo = new THREE.PlaneGeometry(5000, 5000); // Made the ground much larger
            const groundMat = new THREE.MeshStandardMaterial({ color: 0x228B22 });
            const ground = new THREE.Mesh(groundGeo, groundMat);
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            scene.add(ground);
            log("10. Ground added.");

            // --- Mountains ---
            function createMountain(x, z, height, width) {
                const geo = new THREE.ConeGeometry(width, height, 4);
                const mat = new THREE.MeshStandardMaterial({ color: 0x8B7D7B, flatShading: true });
                const mountain = new THREE.Mesh(geo, mat);
                mountain.position.set(x, height / 2, z);
                mountain.rotation.y = Math.PI / 4;
                mountain.castShadow = false;
                scene.add(mountain);
            }
            const mountainPositions = [-100, -70, -40, -10, 20, 50, 80];
            for (let x of mountainPositions) {
                const height = 20 + Math.random() * 10;
                const width = 20 + Math.random() * 10;
                createMountain(x, -200, height, width);
            }
            log("11. Mountains added.");

            // --- Road ---
            const laneCount = 6;
            const laneWidth = 3.5;
            const roadWidth = laneCount * laneWidth;
            const segmentLength = 60;
            const numSegments = 8;
            let roadSegments = [];

            function createRoadSegment(zPos) {
                const roadGeo = new THREE.PlaneGeometry(roadWidth, segmentLength);
                const roadMat = new THREE.MeshStandardMaterial({ color: 0x202020 });
                const road = new THREE.Mesh(roadGeo, roadMat);
                road.rotation.x = -Math.PI / 2;
                road.position.z = zPos - segmentLength / 2;
                road.receiveShadow = true;
                scene.add(road);

                const markings = new THREE.Group();
                const shoulderLineWidth = 0.15;
                const shoulderLineLength = segmentLength;
                const shoulderGeo = new THREE.PlaneGeometry(shoulderLineWidth, shoulderLineLength);
                const shoulderMat = new THREE.MeshBasicMaterial({ color: 0xffffff });

                const leftShoulder = new THREE.Mesh(shoulderGeo, shoulderMat);
                leftShoulder.position.set(-roadWidth / 2 + shoulderLineWidth / 2, 0.01, zPos - segmentLength / 2);
                leftShoulder.rotation.x = -Math.PI / 2;
                markings.add(leftShoulder);

                const rightShoulder = new THREE.Mesh(shoulderGeo, shoulderMat);
                rightShoulder.position.set(roadWidth / 2 - shoulderLineWidth / 2, 0.01, zPos - segmentLength / 2);
                rightShoulder.rotation.x = -Math.PI / 2;
                markings.add(rightShoulder);

                const dashLength = 4, dashGap = 4;
                const dashGeo = new THREE.PlaneGeometry(shoulderLineWidth, dashLength);
                const dashMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
                for (let lane = 1; lane < laneCount; lane++) {
                    const xPos = -roadWidth / 2 + lane * laneWidth;
                    let zStart = zPos - segmentLength / 2 + dashGap / 2;
                    for (let zDash = zStart; zDash < zPos + segmentLength / 2; zDash += dashLength + dashGap) {
                        const dash = new THREE.Mesh(dashGeo, dashMat);
                        dash.position.set(xPos, 0.02, zDash);
                        dash.rotation.x = -Math.PI / 2;
                        markings.add(dash);
                    }
                }

                const dividerLineWidth = 0.1, dividerLineHeight = segmentLength;
                const dividerGeo = new THREE.PlaneGeometry(dividerLineWidth, dividerLineHeight);
                const yellowMat = new THREE.MeshBasicMaterial({ color: 0xFFFF00 });
                const leftDivider = new THREE.Mesh(dividerGeo, yellowMat);
                leftDivider.position.set(-dividerLineWidth * 1.5, 0.03, zPos - segmentLength / 2);
                leftDivider.rotation.x = -Math.PI / 2;
                markings.add(leftDivider);
                const rightDivider = new THREE.Mesh(dividerGeo, yellowMat);
                rightDivider.position.set(dividerLineWidth * 1.5, 0.03, zPos - segmentLength / 2);
                rightDivider.rotation.x = -Math.PI / 2;
                markings.add(rightDivider);

                scene.add(markings);
                return { road, markings };
            }

            for (let i = 0; i < numSegments; i++) roadSegments.push(createRoadSegment(-i * segmentLength));
            log("12. Road segments created.");

            // --- Load GLB Car ---
            let car;
            const loader = new THREE.GLTFLoader();
            const progressDiv = document.getElementById('progress');
            log("13. Attempting to load car.glb...");

            loader.load('car.glb', 
                gltf => {
                    log("SUCCESS: Car model loaded.");
                    progressDiv.style.display = 'none';
                    car = gltf.scene;
                    car.scale.set(2, 2, 2);
                    car.rotation.set(0, -Math.PI / 0, 0); 
                    car.position.set(0, 0.35, 0);
                    car.traverse(node => {
                        if (node.isMesh) {
                            node.castShadow = true;
                            node.receiveShadow = true;
                            if (node.material) {
                                node.material.metalness = 0.2;
                                node.material.roughness = 0.6;
                                node.material.side = THREE.FrontSide;
                            }
                        }
                    });
                    scene.add(car);
                    log("14. Car model added to scene.");
                    animate();
                },
                xhr => {
                    const percent = (xhr.loaded / xhr.total) * 100;
                    progressDiv.textContent = `Loading: ${Math.round(percent)}%`;
                },
                err => {
                    log("ERROR: GLB load failed. Check file name, location, and file integrity.");
                    progressDiv.textContent = "Error loading model.";
                }
            );

            // --- Controls ---
            let moveForward = false, moveBackward = false, turnLeft = false, turnRight = false;
            const maxSpeed = 2.5, acceleration = 0.06, deceleration = 0.04, steeringAngle = 0.03;

            const konamiCode = ['ArrowUp', 'ArrowUp', 'ArrowDown', 'ArrowDown', 'a', 'b', 'd'];
            let inputSequence = [];

            window.addEventListener('keydown', e => {
                const key = e.key;

                // Check for cheat code
                inputSequence.push(key);
                inputSequence = inputSequence.slice(-konamiCode.length);
                if (JSON.stringify(inputSequence) === JSON.stringify(konamiCode)) {
                    debugPanel.style.display = 'block';
                    log("Cheat code entered! Debug panel enabled.");
                }

                // Normal car controls
                switch (key) {
                    case 'ArrowUp': case 'w': moveForward = true; break;
                    case 'ArrowDown': case 's': moveBackward = true; break;
                    case 'ArrowLeft': case 'a': turnLeft = true; break;
                    case 'ArrowRight': case 'd': turnRight = true; break;
                }
            });
            window.addEventListener('keyup', e => {
                switch (e.key) {
                    case 'ArrowUp': case 'w': moveForward = false; break;
                    case 'ArrowDown': case 's': moveBackward = false; break;
                    case 'ArrowLeft': case 'a': turnLeft = false; break;
                    case 'ArrowRight': case 'd': turnRight = false; break;
                }
            });

            // --- UI ---
            const speedometer = document.getElementById('speedometer');
            const scoreDiv = document.getElementById('score');
            const fuelBar = document.getElementById('fuelBar');
            let score = 0;
            let fuel = 150;
            const fuelConsumptionRate = 0.5;

            // --- Traffic ---
            const trafficCars = [];
            const trafficCount = 5;
            const laneXPositions = [];
            for(let i = 0; i < laneCount; i++) {
                laneXPositions.push(-roadWidth / 2 + (i + 0.5) * laneWidth);
            }

            function createTrafficCar() {
                const geometry = new THREE.BoxGeometry(2, 1, 4);
                const material = new THREE.MeshStandardMaterial({ color: 0xff0000 });
                const mesh = new THREE.Mesh(geometry, material);
                const randomLane = laneXPositions[Math.floor(Math.random() * laneCount)];
                mesh.position.set(randomLane, 0.5, -Math.random() * 200 - 50);
                scene.add(mesh);
                trafficCars.push(mesh);
                mesh.passed = false; // Flag to track if the car has been passed
            }

            for (let i = 0; i < trafficCount; i++) createTrafficCar();

            // --- Animate ---
            let speed = 0;
            let lastSpeedBonusTime = 0;
            function animate(time) {
                requestAnimationFrame(animate);

                // Fuel System
                if (speed > 0) {
                    fuel -= speed * fuelConsumptionRate;
                    fuel = Math.max(0, fuel);
                }
                fuelBar.style.width = `${Math.min(100, Math.max(0, fuel))}%`;

                // Speed
                if (fuel > 0) {
                    if (moveForward) speed += acceleration;
                    else if (moveBackward) speed -= acceleration;
                }
                else {
                    speed -= deceleration * 2; // Decelerate faster when out of fuel
                }
                if (!moveForward && !moveBackward) { 
                    if (speed > 0) speed -= deceleration; else if (speed < 0) speed += deceleration; 
                }
                speed = Math.min(Math.max(speed, -maxSpeed / 2), maxSpeed);
                if (Math.abs(speed) < 0.01) speed = 0;

                // Steering
                if (turnLeft && Math.abs(speed) > 0.01) car.rotation.y -= steeringAngle * (speed / maxSpeed);
                if (turnRight && Math.abs(speed) > 0.01) car.rotation.y += steeringAngle * (speed / maxSpeed);

                // Move car
                car.position.x += Math.sin(car.rotation.y) * speed;
                car.position.z += Math.cos(car.rotation.y) * speed;

                // Endless road
                if (roadSegments[0].road.position.z > car.position.z + 10) {
                    const lastSeg = roadSegments[roadSegments.length - 1];
                    roadSegments[0].road.position.z = lastSeg.road.position.z - segmentLength;
                    roadSegments[0].markings.children.forEach(m => {
                        m.position.z = roadSegments[0].road.position.z - 0.01;
                    });
                    roadSegments.push(roadSegments.shift());
                }

                // Move traffic and score
                trafficCars.forEach(t => {
                    t.position.z += 2; // Fixed speed for oncoming traffic
                    const distance = Math.sqrt((car.position.x - t.position.x) ** 2 + (car.position.z - t.position.z) ** 2);
                    
                    if (distance < 2.5) { 
                        // Collision
                        score -= 10;
                        t.position.z = -Math.random() * 200 - 50;
                        t.passed = false; 
                    } else if (t.position.z > car.position.z + 5 && !t.passed) { 
                        // Miss or Close Call
                        if (distance < 4) {
                            score += 50; // 20 for miss + 30 for close call
                        } else {
                            score += 20; // Just a miss
                        }
                        t.position.z = -Math.random() * 200 - 50;
                        t.passed = true;
                    } else if (t.position.z > car.position.z + 5) {
                        t.position.z = -Math.random() * 200 - 50;
                        t.passed = false;
                    }
                });

                // Speed bonus
                if (speed > maxSpeed * 0.8 && time - lastSpeedBonusTime > 500) {
                    score += 500;
                    lastSpeedBonusTime = time;
                }

                score = Math.max(score, 0);
                scoreDiv.textContent = `Score: ${score}`;

                // Smooth camera
                const desiredCameraPos = new THREE.Vector3(
                    car.position.x - Math.sin(car.rotation.y) * 6,
                    5,
                    car.position.z - Math.cos(car.rotation.y) * 6
                );
                camera.position.lerp(desiredCameraPos, 0.1);
                camera.lookAt(car.position.x, car.position.y + 1, car.position.z);

                speedometer.textContent = `Speed: ${Math.abs((speed * 80).toFixed(0))} mph`;
                renderer.render(scene, camera);
            }

        } catch (e) {
            log(`FATAL ERROR: A core function failed. Message: ${e.message}`);
        }
    </script>
</body>
</html>
