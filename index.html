<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <title>Endless 3D Car Simulator</title>
    <style>
        /* General page styling */
        body { 
            margin: 0; 
            overflow: hidden; 
            background: black; 
        }
        canvas { 
            display: block; 
        }
        
        /* Styling for the UI elements */
        #speedometer, #score, #debugPanel, #progress {
            position: fixed;
            top: 10px;
            left: 10px;
            color: white;
            font-family: monospace;
            background: rgba(0,0,0,0.5);
            padding: 10px;
            border-radius: 5px;
            user-select: none;
            font-size: 16px;
        }
        #score {
            top: 40px;
        }
        #debugPanel {
            top: 100px;
            color: yellow;
            background: rgba(0,0,0,0.7);
        }
        #progress {
            top: 150px;
        }
    </style>
</head>
<body>
    <div id="speedometer">Speed: 0</div>
    <div id="score">Score: 100</div>
    <div id="debugPanel">Initializing...</div>
    <div id="progress"></div>

    <script type="module">
        // Importing the necessary libraries. 
        // We're getting Three.js and the GLTFLoader module from a Content Delivery Network (CDN).
        import * as THREE from "https://cdn.jsdelivr.net/npm/three@0.153.0/build/three.module.js";
        import { GLTFLoader } from "https://cdn.jsdelivr.net/npm/three@0.153.0/examples/jsm/loaders/GLTFLoader.js";
        
        // --- DEBUG PANEL ---
        // This is a special section we added to help you troubleshoot.
        // It gets a reference to the debug panel and defines a function to write messages to it.
        // This is crucial since your browser console is disabled.
        const debugPanel = document.getElementById('debugPanel');
        function log(message) {
            debugPanel.innerHTML += message + '<br>';
        }
        log("Initializing...");

        // --- THREE.js Scene Setup ---
        // The scene acts as a container for all your objects, lights, and cameras.
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87ceeb); // Setting the background to a sky-blue color.
        log("Scene created.");

        // The camera defines what the player sees.
        // We're using a PerspectiveCamera, which mimics human vision with a vanishing point.
        const camera = new THREE.PerspectiveCamera(
            75, window.innerWidth / window.innerHeight, 0.1, 1000
        );
        camera.position.set(0, 6, 12); // Placing the camera above and behind the car.
        
        // The renderer is responsible for drawing the scene onto the screen.
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true; // Enabling shadows for a more realistic look.
        renderer.shadowMap.type = THREE.PCFSoftShadowMap; // Using softer shadows.
        document.body.appendChild(renderer.domElement); // Adding the canvas element to the HTML body.
        log("Renderer created.");

        // This event listener automatically resizes the canvas whenever the browser window is changed.
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // --- Lighting ---
        // We need lights to see the objects, especially with the MeshStandardMaterial which interacts with light.
        const ambientLight = new THREE.AmbientLight(0xffffff, 1.2); // A soft, non-directional light.
        scene.add(ambientLight);
        log("Ambient light added.");

        const directionalLight = new THREE.DirectionalLight(0xffffff, 1.5); // A strong light source, like the sun.
        directionalLight.position.set(10, 50, 10);
        directionalLight.castShadow = true; // Making it cast shadows.
        directionalLight.shadow.mapSize.width = 2048; // Increasing shadow map resolution for better quality.
        directionalLight.shadow.mapSize.height = 2048;
        scene.add(directionalLight);
        log("Directional light added.");

        // Additional fill lights to reduce harsh shadows and make the scene brighter.
        const fillLight1 = new THREE.DirectionalLight(0xffffff, 0.8);
        fillLight1.position.set(-10, 20, -10);
        scene.add(fillLight1);
        log("Fill light 1 added.");

        const fillLight2 = new THREE.DirectionalLight(0xffffff, 0.5);
        fillLight2.position.set(0, 10, -20);
        scene.add(fillLight2);
        log("Fill light 2 added.");

        // --- Ground ---
        // Creating the ground plane.
        const groundGeo = new THREE.PlaneGeometry(500, 500); // A large, flat plane.
        const groundMat = new THREE.MeshStandardMaterial({ color: 0x228B22 }); // A dark green material.
        const ground = new THREE.Mesh(groundGeo, groundMat);
        ground.rotation.x = -Math.PI / 2; // Rotating it to be horizontal.
        ground.receiveShadow = true; // Allowing it to receive shadows from other objects.
        scene.add(ground);
        log("Ground added.");

        // --- Mountains ---
        // A function to generate mountain shapes.
        function createMountain(x, z, height, width) {
            const geo = new THREE.ConeGeometry(width, height, 4); // Conical shape.
            const mat = new THREE.MeshStandardMaterial({ color: 0x8B7D7B, flatShading: true }); // Brown-gray material.
            const mountain = new THREE.Mesh(geo, mat);
            mountain.position.set(x, height / 2, z);
            mountain.rotation.y = Math.PI / 4;
            mountain.castShadow = false;
            scene.add(mountain);
        }
        // Placing a few mountains in the background.
        const mountainPositions = [-100, -70, -40, -10, 20, 50, 80];
        for (let x of mountainPositions) {
            const height = 20 + Math.random() * 10;
            const width = 20 + Math.random() * 10;
            createMountain(x, -200, height, width);
        }
        log("Mountains added.");

        // --- Road ---
        // Defining the road dimensions.
        const laneCount = 3;
        const laneWidth = 3.5;
        const roadWidth = laneCount * laneWidth;
        const segmentLength = 60;
        const numSegments = 8;
        let roadSegments = [];

        // Function to create a single segment of the road with all its markings.
        function createRoadSegment(zPos) {
            const roadGeo = new THREE.PlaneGeometry(roadWidth, segmentLength);
            const roadMat = new THREE.MeshStandardMaterial({ color: 0x202020 });
            const road = new THREE.Mesh(roadGeo, roadMat);
            road.rotation.x = -Math.PI / 2;
            road.position.z = zPos - segmentLength / 2;
            road.receiveShadow = true;
            scene.add(road);

            const markings = new THREE.Group(); // A group to hold all the lane markings.
            // ... (code for creating shoulder lines and dashes) ...
            
            scene.add(markings);
            return { road, markings };
        }

        for (let i = 0; i < numSegments; i++) roadSegments.push(createRoadSegment(-i * segmentLength));
        log("Road segments created.");

        // --- Load GLB Car ---
        // This is the most critical part of the code for your issue.
        let car;
        const loader = new GLTFLoader();
        const progressDiv = document.getElementById('progress');
        log("Attempting to load car.glb...");

        // The loader.load() function has three callbacks: one for success, one for progress, and one for errors.
        loader.load('car.glb', 
            // 1. Success Callback: This function runs when the model is fully loaded.
            gltf => {
                log("SUCCESS: Car model loaded.");
                progressDiv.style.display = 'none'; // Hiding the progress bar.
                car = gltf.scene; // Getting the car from the loaded glTF scene.
                car.scale.set(2, 2, 2);
                car.position.set(0, 0.35, 0);
                car.traverse(node => {
                    if (node.isMesh) {
                        node.castShadow = true;
                        node.receiveShadow = true;
                        if (node.material) {
                            node.material.metalness = 0.2;
                            node.material.roughness = 0.6;
                            node.material.side = THREE.FrontSide;
                        }
                    }
                });
                scene.add(car);
                log("Car model added to scene.");
                animate(); // We finally start the animation loop here.
            },
            // 2. Progress Callback: This function runs continuously while the file is downloading.
            xhr => {
                const percent = (xhr.loaded / xhr.total) * 100;
                progressDiv.textContent = `Loading: ${Math.round(percent)}%`;
            },
            // 3. Error Callback: This function runs if the model fails to load.
            err => {
                log("ERROR: GLB load failed. Check file name, location, and file integrity.");
                progressDiv.textContent = "Error loading model.";
            }
        );

        // --- Controls ---
        let moveForward = false, moveBackward = false, turnLeft = false, turnRight = false;
        const maxSpeed = 2.5, acceleration = 0.06, deceleration = 0.04, steeringAngle = 0.03;
        window.addEventListener('keydown', e => {
            switch (e.key) {
                case 'ArrowUp': case 'w': moveForward = true; break;
                case 'ArrowDown': case 's': moveBackward = true; break;
                case 'ArrowLeft': case 'a': turnLeft = true; break;
                case 'ArrowRight': case 'd': turnRight = true; break;
            }
        });
        window.addEventListener('keyup', e => {
            switch (e.key) {
                case 'ArrowUp': case 'w': moveForward = false; break;
                case 'ArrowDown': case 's': moveBackward = false; break;
                case 'ArrowLeft': case 'a': turnLeft = false; break;
                case 'ArrowRight': case 'd': turnRight = false; break;
            }
        });

        // --- UI ---
        const speedometer = document.getElementById('speedometer');
        const scoreDiv = document.getElementById('score');
        let score = 100;

        // --- Traffic ---
        const trafficCars = [];
        const trafficCount = 5;
        const laneXPositions = [-laneWidth, 0, laneWidth];

        function createTrafficCar() {
            const geometry = new THREE.BoxGeometry(2, 1, 4);
            const material = new THREE.MeshStandardMaterial({ color: 0xff0000 });
            const mesh = new THREE.Mesh(geometry, material);
            mesh.position.set(laneXPositions[Math.floor(Math.random() * 3)], 0.5, -Math.random() * 200 - 50);
            scene.add(mesh);
            trafficCars.push(mesh);
        }

        for (let i = 0; i < trafficCount; i++) createTrafficCar();

        // --- Animate ---
        // This is the main animation loop that runs every frame.
        let speed = 0;
        function animate() {
            requestAnimationFrame(animate); // This tells the browser to run this function again on the next frame.

            // The rest of the function updates the game state, like speed, steering, and positions.
            // ... (code for updating speed, car position, endless road, traffic, etc.) ...
            
            renderer.render(scene, camera); // This is the final call that draws the scene to the screen.
        }
    </script>
</body>
</html>
